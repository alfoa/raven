"""
Created on September 1st, 2017
@author: rouxpn
"""

import os
from shutil import copyfile
from decimal import Decimal
import xml.etree.ElementTree as ET
from xml.etree.ElementTree import Element, SubElement, Comment
from xml.dom import minidom
from random import *

class XSCreator():

  def tabMapping(self, tab):
    """
      Links the tabulation number to the actual tabulation points
      @ In, tab, string, referes to the tabulation number
      @ Out, tabList, list, lists of all the tabulation parameters
      @ Out, valueList, lists of all the tabulation values
    """
    mappingTree = ET.parse('tabMapping.xml')
    mappingRoot = mappingTree.getroot()
    for tabulationXML in mappingRoot.getiterator('tabulation'):
      if tab == tabulationXML.attrib.get('set'):
        tabList = []
        valueList = []
        for tabXML in tabulationXML.getiterator('tab'):
          tabList.append(tabXML.attrib.get('name'))
          valueList.append(tabXML.text)
    return tabList, valueList

  def prettify(self, elem):
    """
      Returns a pretty-printed XML string for the Element
      @ In, elem, xml.etree.ElementTree.Element
      @ Out, None
    """
    rough_string = ET.tostring(elem, 'utf-8')
    reparsed = minidom.parseString(rough_string)
    return reparsed.toprettyxml(indent="  ")

  def generateRandomName(self):
    """
      Generates a random file name for the modified file
      @ In, None
      @ Out, string, random file name under string format
    """
    return str(randint(1,1000000000000))+'.xml'

  def generateXML(self):
    """
      Creates an XML file from the interface
      @ In, None
      @ Out, modifiedFile, string, name of the xml file created (under a dummy name)
    """
    top = Element('scaling_library')
    comment = Comment('Generated by rouxpn')
    top.append(comment)

    for XS in self.listedDict.iterkeys():
      for tabulation in self.listedDict.get('XS').iterkeys():
        topChild = SubElement(top, 'set')
        tabList, valueList = self.tabMapping(tabulation)
        if self.booleanTab is True:
          for i in xrange (0,len(tabList)):
            tabChild = SubElement(topChild, 'tab', {'name':tabList[i]})
            tabChild.text = valueList[i]
        for material in self.listedDict.get('XS').get(tabulation).iterkeys():
          tabulationChild = SubElement(topChild, 'library', {'lib_name':material.lower()})
          for isotope in self.listedDict.get('XS').get(tabulation).get(material).iterkeys():
            for type in self.listedDict.get('XS').get(tabulation).get(material).get(isotope).iterkeys():
              libraryChild = SubElement(tabulationChild, 'isotope', {'id':isotope.lower(), 'type':type.lower()})
              for reaction in self.listedDict.get('XS').get(tabulation).get(material).get(isotope).get(type).iterkeys():
                groupList = []
                valueList = []
                count = 0
                for group,value in self.listedDict.get('XS').get(tabulation).get(material).get(isotope).get(type).get(reaction).iteritems():
                  count = count + 1
                  numberOfGroupsPerturbed = len(self.listedDict.get('XS').get(tabulation).get(material).get(isotope).get(type).get(reaction).keys())
                  groupList.append(group)
                  valueList.append(value)
                  group.join(',')
                  if count == numberOfGroupsPerturbed:
                    groups = ','.join(str(e) for e in groupList)
                    values = ','.join(str(f) for f in valueList)
                    reactionChild = SubElement(libraryChild, reaction.lower(), {'g':groups})
                    reactionChild.text = values

    modifiedFile = self.generateRandomName()
    file_obj = open(modifiedFile, 'w')
    file_obj.write(self.prettify(top))
    return modifiedFile

  def clean_empty(self, leanDict):
    """
      Removes all the empty string in the nested dictionary reconstructedDict
      @ In, reconstructedDict, dictionary,  nested dictionary
      @ Out, leanReconstructedDict, dictionary, nested dictionary without trailing blanks
    """
    if not isinstance(leanDict, (dict, list)):
        return leanDict
    if isinstance(leanDict, list):
        return [v for v in (self.clean_empty(v) for v in leanDict) if v]
    return {k: v for k, v in ((k, self.clean_empty(v)) for k, v in leanDict.items()) if v}


  def __init__(self, inputFiles, booleanTab, **pertDict):
    """
      Parse the PHISICS XS.xml data file
      @ In, inputFiles, string, file name the perturbed cross sections are printed into
      @ In, booleanTab, Boolean, True if a tabulation mapping is provided in the problem input. False otherwise.
                                  This variable is ontrolled by the xml node <tabulation> in the raven input
      @ In, pertDict, dictionary, dictionary of perturbed variables
      @ Out, None
    """
    self.booleanTab = booleanTab
    self.pertDict = pertDict
    for key, value in self.pertDict.iteritems():
      self.pertDict[key] = '%.5E' % Decimal(str(value)) #convert the values into scientific values
    self.inputFiles = inputFiles
    self.tree = ET.parse(self.inputFiles)
    self.root = self.tree.getroot()
    self.listedDict = self.fileReconstruction(self.pertDict)
    modifiedFile = self.generateXML()
    self.printInput(modifiedFile)

  def fileReconstruction(self, deconstructedDict):
    """
      Converts the formatted dictionary -> {'XS|FUEL1|U235|FISSION|1':1.30, 'XS|FUEL2|U238|ABS|2':4.69}
      into a dictionary of dictionaries that has the format -> {'XS':{'FUEL1':{'U235':{'FISSION':{'1':1.30}}}}, 'FUEL2':{'U238':{'ABS':{'2':4.69}}}}
      @ In, deconstructedDict, dictionary
      @ Out, reconstructedDict, dictionary
    """
    reconstructedDict           = {}
    perturbedPhysicalParameters = []
    perturbedTabulationPoint    = []
    perturbedMaterials          = []
    perturbedIsotopes           = []
    perturbedTypes              = []
    perturbedReactions          = []
    perturbedGroups             = []

    pertDictSet = set(self.pertDict)
    deconstructedDictSet = set(deconstructedDict)
    for i in pertDictSet.intersection(deconstructedDictSet):
      splittedKeywords = i.split('|')
      perturbedPhysicalParameters.append(splittedKeywords[0])
      perturbedTabulationPoint.append(splittedKeywords[1])
      perturbedMaterials.append(splittedKeywords[2])
      perturbedIsotopes.append(splittedKeywords[3])
      perturbedTypes.append(splittedKeywords[4])
      perturbedReactions.append(splittedKeywords[5])
      perturbedGroups.append(splittedKeywords[6])

    for i in xrange (0,len(perturbedPhysicalParameters)):
      reconstructedDict[perturbedPhysicalParameters[i]] = {}
      for j in xrange (0,len(perturbedTabulationPoint)):
        reconstructedDict[perturbedPhysicalParameters[i]][perturbedTabulationPoint[j]] = {}
        for k in xrange (0,len(perturbedMaterials)):
          reconstructedDict[perturbedPhysicalParameters[i]][perturbedTabulationPoint[j]][perturbedMaterials[k]] = {}
          for l in xrange (0,len(perturbedIsotopes)):
            reconstructedDict[perturbedPhysicalParameters[i]][perturbedTabulationPoint[j]][perturbedMaterials[k]][perturbedIsotopes[l]] = {}
            for m in xrange (0,len(perturbedReactions)):
              reconstructedDict[perturbedPhysicalParameters[i]][perturbedTabulationPoint[j]][perturbedMaterials[k]][perturbedIsotopes[l]][perturbedTypes[m]] = {}
              for n in xrange (0,len(perturbedReactions)):
                reconstructedDict[perturbedPhysicalParameters[i]][perturbedTabulationPoint[j]][perturbedMaterials[k]][perturbedIsotopes[l]][perturbedTypes[m]][perturbedReactions[n]] = {}
                for o in xrange (0,len(perturbedGroups)):
                  reconstructedDict[perturbedPhysicalParameters[i]][perturbedTabulationPoint[j]][perturbedMaterials[k]][perturbedIsotopes[l]][perturbedTypes[m]][perturbedReactions[n]][perturbedGroups[o]] = {}
    for typeKey, value in deconstructedDict.iteritems():
      if typeKey in pertDictSet:
        keyWords = typeKey.split('|')
        reconstructedDict[keyWords[0]][keyWords[1]][keyWords[2]][keyWords[3]][keyWords[4]][keyWords[5]][keyWords[6]] = value
    leanReconstructedDict = self.clean_empty(reconstructedDict)
    return leanReconstructedDict

  def removeRandomlyNamedFiles(self, modifiedFile):
    """
      Removes the temporary file with a random name in the working directory
      @ In, modifiedFile, string
      @ Out, None
    """
    os.remove(modifiedFile)

  def printInput(self, modifiedFile):
    """
      Prints out the new input
      @ In, modifiedFile, string, output file name
      @ Out, None
    """
    copyfile(modifiedFile, self.inputFiles)
    self.removeRandomlyNamedFiles(modifiedFile)


